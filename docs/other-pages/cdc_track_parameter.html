<!DOCTYPE html>
<html>

<head>
    <title>COMET CDC Track Parameter</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #1a1a2e;
            font-family: Arial, sans-serif;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            max-width: 300px;
        }

        .control-group {
            margin: 10px 0;
        }

        button {
            margin: 5px;
            padding: 8px 15px;
            background: #2196f3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button:hover {
            background: #1976d2;
        }

        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }

        .param-control {
            margin: 8px 0;
        }

        .param-control label {
            display: inline-block;
            width: 80px;
            color: #4fc3f7;
        }

        .param-control input {
            width: 120px;
        }
    </style>
</head>

<body>
    <div id="controls">
        <h3>COMET CDC Track parameterization</h3>

        <div class="control-group">
            <button id="reset-view">Reset View</button>
            <button id="reset-all">Reset All</button>
        </div>

        <div class="control-group">
            <div class="param-control">
                <label>φ :</label>
                <input type="range" id="phi-slider" min="0" max="360" step="1" value="45">
                <span id="phi-value">45°</span>
            </div>

            <div class="param-control">
                <label>κ=q/pt:</label>
                <input type="range" id="kappa-slider" min="0.1" max="2" step="0.1" value="0.8">
                <span id="kappa-value">0.4</span>
            </div>

            <div class="param-control">
                <label>ψ (py,px):</label>
                <input type="range" id="psi-slider" min="0" max="90" step="1" value="30">
                <span id="psi-value">30°</span>
            </div>

            <div class="param-control">
                <label>λ=pz/pt:</label>
                <input type="range" id="lambda-slider" min="-2" max="2" step="0.1" value="0.5">
                <span id="lambda-value">0.5</span>
            </div>

            <div class="param-control">
                <label>z0:</label>
                <input type="range" id="z0-slider" min="-4" max="4" step="0.1" value="0">
                <span id="z0-value">0.0</span>
            </div>

            <div class="control-group">
                <div>Mouse Left Button: Rotate View</div>
                <div>Mouse Right Button: Pan View</div>
                <div>Mouse Wheel: Zoom In/Out</div>
            </div>

            <div> Author: Yao Zhang (zhangyao@ihep.ac.cn)</div>
        </div>
    </div>
     <canvas id="xyCanvas" width="200" height="200" style="position:absolute; bottom:20px; right:20px;
         border:1px solid #4fc3f7; background:rgba(0,0,0,0.0); pointer-events:none;">
     </canvas>

     <div id="status">Ready</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script>
        // 创建渲染器
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        LINEWIDTH = 5;
        const COLOR_SOFT_RED = 0xE15759;
        const COLOR_WARM_ORANGE = 0xF28E2C;
        const COLOR_PINE_GREEN = 0x59A14F;
        const COLOR_LAKE_CYAN = 0x76B7B2;
        const COLOR_MIST_BLUE = 0x4E79A7;
        const COLOR_ASH_PURPLE = 0xB07AA1;
        const COLOR_NUDE_PINK = 0xFF9DA7;
        const COLOR_CRIMSON = 0xDC143C;
        const COLOR_SAND_BROWN = 0x8C564B;
        const COLOR_BLACK = 0x000000;
        const COLOR_WHITE = 0xFFFFFF;
        const COLOR_GRAY = 0x888888;

        // 场景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        // 相机
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(10, 8, 10);
        camera.lookAt(0, 0, 0);

        // 轨道控制器
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = true;
        controls.minDistance = 3;
        controls.maxDistance = 30;

        // 灯光
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 15);
        scene.add(directionalLight);

        // =================== 物理参数 ===================
        let params = {
            q: -1,          // 电荷 q
            kappa: 0.4,      // curvature κ = q/pt
            psi: 30,        // ψ angle that px,py make with X axis in XY plane
            phi0: 45,        // φ angle that point P makes with X axis in XY plane
            lambda: 0.5,    // λ = pz/pt
            z0: 0,        // initial z position
            cylinder_radius: 5,      // reference cylinder radius of the CDC
            cylinder_length: 8       // reference cylinder length
        };

        // =================== 创建几何元素 ===================

        // 1. 创建半透明蓝色圆柱（探测器几何）
        function createDetectorCylinder() {
            const geometry = new THREE.CylinderGeometry(
                params.cylinder_radius, params.cylinder_radius, params.cylinder_length, 64, 1, true
            );
            geometry.rotateX(Math.PI / 2);

            const material = new THREE.MeshPhongMaterial({
                color: COLOR_LAKE_CYAN,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide
            });

            const cylinder = new THREE.Mesh(geometry, material);
            cylinder.name = "DetectorCylinder";

            return cylinder;
        }

        // 2. 创建点P（蓝色小球）
        function createPointP() {
            const geometry = new THREE.SphereGeometry(0.05, 6, 6);
            const material = new THREE.MeshPhongMaterial({
                color: COLOR_MIST_BLUE,
                shininess: 100
            });

            const sphere = new THREE.Mesh(geometry, material);
            sphere.name = "PointP";

            return sphere;
        }

        // 3. 创建径迹- 根据新的螺旋线公式
        function createTrack() {
            // 计算点P的位置（圆柱表面）
            const phiRad = THREE.MathUtils.degToRad(params.phi0);

            // 点P在圆柱表面
            const x0 = params.cylinder_radius * Math.cos(phiRad);
            const y0 = params.cylinder_radius * Math.sin(phiRad);
            const zP = params.z0; // 在圆柱中间高度

            // 计算螺旋径迹参数
            const R = 1 / (2 * Math.abs(params.kappa)); // 曲率半径
            const points = [];
            const numPoints = 200;

            // ψ角是px,py在XY平面内的夹角
            const psiRad = THREE.MathUtils.degToRad(params.psi);

            // 计算初始动量方向（在XY平面内）
            // px方向由ψ决定
            const px = Math.cos(psiRad);
            const py = Math.sin(psiRad);
            const pz = params.lambda * Math.sqrt(px * px + py * py);

            // 归一化XY平面内的动量
            const pT = Math.sqrt(px * px + py * py); // 横向动量大小

            for (let i = 0; i <= numPoints; i++) {
                const t = (i / numPoints) * 4 * Math.PI; // 增加t范围以获得更长的径迹
                const k = Math.sign(params.kappa);

                // 根据曲率计算旋转角度
                const theta = k * t;

                // 螺旋线方程
                const x = x0 + (Math.sin(theta + psiRad) - Math.sin(psiRad)) * R / pT;
                const y = y0 + (Math.cos(psiRad) - Math.cos(theta + psiRad)) * R / pT;
                const z = zP + params.lambda * theta * R;

                points.push(new THREE.Vector3(x, y, z));
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: COLOR_SOFT_RED,
                linewidth: LINEWIDTH
            });

            return new THREE.Line(geometry, material);
        }

        // 4. 创建φ角 - 点P在圆柱上的位置
        function createPhiArc() {
            const phiRad = THREE.MathUtils.degToRad(params.phi0);
            const radius = params.cylinder_radius * 0.5;
            const origin = new THREE.Vector3(0, 0, 0.0);
            const dirA = new THREE.Vector3(1, 0, 0);
            const dirB = new THREE.Vector3(Math.cos(phiRad), Math.sin(phiRad), 0);
            return createAngleArc(origin, dirA, dirB, radius, { color: COLOR_PINE_GREEN, label: 'φ', labelScale: 1.0, showLabel: false, labelOffset: 0.08 });
        }

        // 5. 创建ψ角- pt，x轴夹角
        function createPsiArc() {
            const phiRad = THREE.MathUtils.degToRad(params.phi0);
            const psiRad = THREE.MathUtils.degToRad(params.psi);
            // 点P的位置
            const x0 = params.cylinder_radius * Math.cos(phiRad);
            const y0 = params.cylinder_radius * Math.sin(phiRad);
            const zP = params.z0;
            const origin = new THREE.Vector3(x0, y0, zP);
            const dirA = new THREE.Vector3(1, 0, 0);
            const dirB = new THREE.Vector3(Math.cos(psiRad), Math.sin(psiRad), 0); // momentum transverse
            const arcRadius = 1.5;
            return createAngleArc(origin, dirA, dirB, arcRadius, { color: COLOR_SOFT_RED, label: 'ψ', labelScale: 0.9, showLabel: false, labelOffset: 0.06 });
        }

        function createLambdaArc(pz,pt) {
            // Draw λ as the angle between pt (transverse) and p (full momentum)
            // Origin at point P, arc lies in the plane spanned by pt and p
            const phiRad = THREE.MathUtils.degToRad(params.phi0);
            const psiRad = THREE.MathUtils.degToRad(params.psi);
            const x0 = params.cylinder_radius * Math.cos(phiRad);
            const y0 = params.cylinder_radius * Math.sin(phiRad);
            const zP = params.z0;

            // transverse momentum magnitude and full components
            const ptVal = params.kappa !== 0 ? 1 / Math.abs(params.kappa) : 10;
            const px = ptVal * Math.cos(psiRad);
            const py = ptVal * Math.sin(psiRad);
            const pzVal = params.lambda * ptVal;

            // directions: pt (in XY plane) and full momentum p (has z component)
            const ptDir = new THREE.Vector3(Math.cos(psiRad), Math.sin(psiRad), 0).normalize();
            const pDir = new THREE.Vector3(Math.cos(psiRad), Math.sin(psiRad), params.lambda).normalize();

            const origin = new THREE.Vector3(x0, y0, zP);

            // choose a reasonable radius for the arc (small, relative to detector)
            const arcRadius = Math.max(0.4, Math.min(1.5, ptVal * 0.5));

            return createAngleArc(origin, ptDir, pDir, arcRadius, { color: COLOR_CRIMSON, label: 'λ', labelScale: 1.5, showLabel: true, labelOffset: 0.06 });
        }

        // 6. 创建Z平面（灰色半透明平面） — 位于圆柱底部 (z = -cylinder_length/2)
        function createZPlane() {
            const geometry = new THREE.PlaneGeometry(15, 15);
            const material = new THREE.MeshPhongMaterial({
                color: COLOR_GRAY,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });

            const plane = new THREE.Mesh(geometry, material);
            plane.name = "ZPlane";
            // 平面默认位于 XY 平面，把它移动到圆柱底部 (z = -length/2)
            const zPos = -Math.abs(params.cylinder_length) / 2 - 0.01; // 小偏移以避免 Z-fighting
            plane.position.set(0, 0, zPos);

            return plane;
        }

        // createLabel: 可选传入 scale 和 alwaysOnTop 参数
        // scale: 如果为 null 则使用默认 (1.5, 0.75)，否则设置为 (scale, scale*0.5)
        // alwaysOnTop: 如果为 true，则禁用深度测试并将 renderOrder 拉高，避免被几何体遮挡
        function createLabel(text, position, color = 0xffffff, scale = null, alwaysOnTop = false) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            // 设置合适的画布大小
            canvas.width = 256;
            canvas.height = 128;

            // 清空画布
            context.clearRect(0, 0, canvas.width, canvas.height);

            // 配置文字样式
            context.font = 'Bold 64px Arial';
            context.fillStyle = '#' + color.toString(16).padStart(6, '0'); // 转换 hex 为 CSS 颜色
            context.textAlign = 'center';
            context.textBaseline = 'middle';

            // 绘制文字（居中）
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            // 创建纹理并标记需要更新
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            // 创建 sprite
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true
            });
            if (alwaysOnTop) {
                material.depthTest = false;
                material.depthWrite = false;
            }
            const sprite = new THREE.Sprite(material);

            // 调整缩放（根据画布大小）
            if (scale === null) sprite.scale.set(1.5, 0.75, 1);
            else sprite.scale.set(scale, scale * 0.5, 1);
            sprite.position.copy(position);
            if (alwaysOnTop) sprite.renderOrder = 999;

            return sprite;
        }

        // 替代实现：手工切分的虚线（不依赖 LineDashedMaterial 的 computeLineDistances）
        // pointsArray: Array<THREE.Vector3>, opts: { dashSize, gapSize, color, linewidth }
        function createDashedLine(pointsArray, opts = {}) {
            const dashSize = opts.dashSize !== undefined ? opts.dashSize : 0.8;
            const gapSize = opts.gapSize !== undefined ? opts.gapSize : 0.6;
            const color = opts.color !== undefined ? opts.color : COLOR_GRAY;
            const linewidth = opts.linewidth !== undefined ? opts.linewidth : 1;

            if (!pointsArray || pointsArray.length < 2) return new THREE.Group();

            // 1) 计算每段长度及总长
            const segLens = [];
            let totalLen = 0;
            for (let i = 0; i < pointsArray.length - 1; i++) {
                const a = pointsArray[i];
                const b = pointsArray[i + 1];
                const l = a.distanceTo(b);
                segLens.push(l);
                totalLen += l;
            }
            if (totalLen <= 0) return new THREE.Group();

            // 2) 生成 dash 段
            const dashSegments = [];
            const step = dashSize + gapSize;
            for (let start = 0; start < totalLen; start += step) {
                const ds = start;
                const de = Math.min(start + dashSize, totalLen);
                if (de <= ds) continue;

                let accum = 0;
                for (let i = 0; i < segLens.length; i++) {
                    const segStart = accum;
                    const segEnd = accum + segLens[i];
                    accum = segEnd;
                    const ovStart = Math.max(ds, segStart);
                    const ovEnd = Math.min(de, segEnd);
                    if (ovEnd > ovStart + 1e-9) {
                        const localStartT = (ovStart - segStart) / (segLens[i] || 1);
                        const localEndT = (ovEnd - segStart) / (segLens[i] || 1);
                        const p0 = pointsArray[i];
                        const p1 = pointsArray[i + 1];
                        const segP0 = new THREE.Vector3().copy(p0).lerp(p1, localStartT);
                        const segP1 = new THREE.Vector3().copy(p0).lerp(p1, localEndT);
                        dashSegments.push(segP0, segP1);
                    }
                }
            }

            // 3) 构建几何并返回 LineSegments
            const positions = new Float32Array(dashSegments.length * 3);
            for (let i = 0; i < dashSegments.length; i++) {
                positions[i * 3 + 0] = dashSegments[i].x;
                positions[i * 3 + 1] = dashSegments[i].y;
                positions[i * 3 + 2] = dashSegments[i].z;
            }
            const geom = new THREE.BufferGeometry();
            geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.LineBasicMaterial({ color: color, linewidth: linewidth });
            return new THREE.LineSegments(geom, mat);
        }

        // 通用：在两个方向向量之间绘制角弧（origin 为圆心）
        // origin: THREE.Vector3, dirA/dirB: THREE.Vector3 (方向向量)，radius: number 或 null
        // options: { color, segments, label, labelScale, showLabel, alwaysOnTop, labelOffset }
        function createAngleArc(origin, dirA, dirB, radius = null, options = {}) {
            const color = options.color !== undefined ? options.color : COLOR_NUDE_PINK;
            const segments = options.segments || 28;
            const label = options.label || '';
            const labelScale = options.labelScale || 0.9;
            const showLabel = options.showLabel !== undefined ? options.showLabel : true;
            const alwaysOnTop = options.alwaysOnTop !== undefined ? options.alwaysOnTop : true;
            const labelOffset = options.labelOffset !== undefined ? options.labelOffset : 0.06;

            const u = dirA.clone().normalize();
            const proj = u.clone().multiplyScalar(dirB.dot(u));
            let v = dirB.clone().sub(proj);
            if (v.length() < 1e-6) {
                v = new THREE.Vector3(-u.y, u.x, 0);
                if (v.length() < 1e-6) v = new THREE.Vector3(0, 0, 1);
            }
            v.normalize();

            const cosA = THREE.MathUtils.clamp(u.dot(dirB), -1, 1);
            const angle = Math.acos(cosA);

            if (radius === null) radius = Math.max(0.4, 0.25);

            const pts = [];
            for (let i = 0; i <= segments; i++) {
                const t = (i / segments) * angle;
                const ptComp = u.clone().multiplyScalar(radius * Math.cos(t));
                const vComp = v.clone().multiplyScalar(radius * Math.sin(t));
                pts.push(origin.clone().add(ptComp).add(vComp));
            }

            const grp = new THREE.Group();
            const arc = new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), new THREE.LineBasicMaterial({ color: color, linewidth: 2 }));
            grp.add(arc);

            if (showLabel && label) {
                const midT = angle * 0.5;
                const midPos = origin.clone().add(u.clone().multiplyScalar(radius * Math.cos(midT))).add(v.clone().multiplyScalar(radius * Math.sin(midT)));
                midPos.add(v.clone().multiplyScalar(labelOffset));
                grp.add(createLabel(label, midPos, color, labelScale, alwaysOnTop));
            }

            return grp;
        }


        // 7. 创建文字标注
        function createTextLabels() {
            const group = new THREE.Group();

            // 点P的位置
            const phiRad = THREE.MathUtils.degToRad(params.phi0);
            const x0 = params.cylinder_radius * Math.cos(phiRad);
            const y0 = params.cylinder_radius * Math.sin(phiRad);
            const zP = 0;

            return group;
        }

        // 8. 创建坐标轴（红绿蓝）
        function createCoordinateAxes() {
            const group = new THREE.Group();
            const axisLength = 8;
            const headLength = 0.4;
            const headWidth = 0.2;

            // X轴（红色箭头）
            const xDir = new THREE.Vector3(1, 0, 0);
            const xOrigin = new THREE.Vector3(0, 0, 0);
            const xArrow = new THREE.ArrowHelper(xDir, xOrigin, axisLength, COLOR_SOFT_RED, headLength, headWidth);
            group.add(xArrow);

            // Y轴（绿色箭头）
            const yDir = new THREE.Vector3(0, 1, 0);
            const yOrigin = new THREE.Vector3(0, 0, 0);
            const yArrow = new THREE.ArrowHelper(yDir, yOrigin, axisLength, COLOR_PINE_GREEN, headLength, headWidth);
            group.add(yArrow);

            // Z轴（蓝色箭头）
            const zDir = new THREE.Vector3(0, 0, 1);
            const zOrigin = new THREE.Vector3(0, 0, 0);
            const zArrow = new THREE.ArrowHelper(zDir, zOrigin, axisLength, COLOR_MIST_BLUE, headLength, headWidth);
            group.add(zArrow);

            // add 3D axis labels (restore original positions)
            group.add(createLabel('X', new THREE.Vector3(axisLength + 0.2, 0, 0), COLOR_SOFT_RED));
            group.add(createLabel('Y', new THREE.Vector3(0.5, axisLength - 0.2, 0), COLOR_PINE_GREEN));
            group.add(createLabel('Z', new THREE.Vector3(0, 0, axisLength + 0.2), COLOR_MIST_BLUE));
            group.add(createLabel('O', new THREE.Vector3(0.5, 0.5, 0), COLOR_GRAY));
            //group.add(createLabel('XZ-Plane', new THREE.Vector3(8, 2, 0), COLOR_GRAY));
            return group;
        }

        // 9. 创建动量方向指示器
        function createMomentumIndicator() {
            const group = new THREE.Group();

            const phiRad = THREE.MathUtils.degToRad(params.phi0);
            const psiRad = THREE.MathUtils.degToRad(params.psi);

            // 点P的位置（3D圆柱坐标）
            const x0 = params.cylinder_radius * Math.cos(phiRad);
            const y0 = params.cylinder_radius * Math.sin(phiRad);
            const zP = params.z0;

            //pxyz,pt
            const pt = params.kappa !== 0 ? 1 / Math.abs(params.kappa) : 10; // 避免除以零
            const p = Math.sqrt(pt * pt + (params.lambda * pt) * (params.lambda * pt));
            const px = pt * Math.cos(psiRad);
            const py = pt * Math.sin(psiRad);
            const pz = params.lambda * pt;

            // 动量方向向量（ψ相对于径向方向）
            const momentumDir = new THREE.Vector3(
                Math.cos(psiRad),
                Math.sin(psiRad),
                params.lambda
            ).normalize();
            // directions: use sign for axis-aligned components and keep lengths absolute
            const pxDir = new THREE.Vector3(Math.sign(px) || 1, 0, 0).normalize();
            const pyDir = new THREE.Vector3(0, Math.sign(py) || 1, 0).normalize();
            const pzDir = new THREE.Vector3(0, 0, (pz >= 0 ? 1 : -1)).normalize();
            const ptDir = new THREE.Vector3(
                    Math.cos(psiRad),
                    Math.sin(psiRad),
                    0
                ).normalize();

            const momentumLength = p;
            const arrowOrigin = new THREE.Vector3(x0, y0, zP);

            //  使用 ArrowHelper 自动处理3D方向
            const arrowHelper = new THREE.ArrowHelper(
                momentumDir,           // 方向（已归一化）
                arrowOrigin,           // 起点
                momentumLength,        // 长度
                COLOR_WARM_ORANGE,              // 颜色
                momentumLength * 0.1,  // 箭头长度
                momentumLength * 0.05  // 箭头宽度
            );
            const pxArrowHelper = new THREE.ArrowHelper(
                pxDir,           // 方向（已归一化）
                arrowOrigin,           // 起点
                Math.abs(px), // 长度
                COLOR_SOFT_RED,              // 颜色
                0.2,  // 箭头长度
                0.2  // 箭头宽度
            );
            const pyArrowHelper = new THREE.ArrowHelper(
                pyDir,           // 方向（已归一化）
                arrowOrigin,           // 起点
                Math.abs(py),// 长度
                COLOR_PINE_GREEN,              // 颜色
                0.2,  // 箭头长度
                0.2  // 箭头宽度
            );
            const pzArrowHelper = new THREE.ArrowHelper(
                pzDir,           // 方向（已归一化）
                arrowOrigin,           // 起点
                Math.abs(pz), // 长度
                COLOR_MIST_BLUE,              // 颜色
                0.2,  // 箭头长度
                0.2  // 箭头宽度
            );
            const ptArrowHelper = new THREE.ArrowHelper(
                new THREE.Vector3(
                    Math.cos(psiRad),
                    Math.sin(psiRad),
                    0
                ).normalize(),           // 方向（已归一化）
                arrowOrigin,           // 起点
                pt, // 长度
                COLOR_LAKE_CYAN,              // 颜色
                0.2,  // 箭头长度
                0.2  // 箭头宽度
            );
            // // a dashed line from point of pt to point of p
            // const pz2ptLine = createDashedLine([
            //     new THREE.Vector3(x0 + px, y0 + py, zP + 0),
            //     new THREE.Vector3(x0, y0, zP + pz)
            // ], { color: COLOR_LAKE_CYAN, dashSize: 1, gapSize: 2, linewidth: LINEWIDTH });
            // dashed line from origin O to P' (3D) to illustrate φ reference
            const opDashed = createDashedLine([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(x0, y0, 0)
            ], { color: COLOR_GRAY, dashSize: 0.5, gapSize: 0.5 });
            group.add(arrowHelper);
            group.add(pxArrowHelper);
            group.add(pyArrowHelper);
            group.add(pzArrowHelper);
            group.add(ptArrowHelper);
            // group.add(pz2ptLine);
            group.add(opDashed);


            // Add minimal 3D labels: only 'pz' and 'p' as requested
            // pz label at the tip of the pz arrow (slightly offset outward)
            const pzTip = arrowOrigin.clone().add(pzDir.clone().multiplyScalar(Math.abs(pz) + 0.18));
            group.add(createLabel('pz', pzTip, COLOR_MIST_BLUE, null, true));

            // pt label at the tip of the pt arrow (slightly offset outward)
            const ptTip = arrowOrigin.clone().add(ptDir.clone().multiplyScalar(Math.abs(pt) + 0.18));
            group.add(createLabel('pt', ptTip, COLOR_MIST_BLUE, null, true));

            // p label at the tip of the full momentum vector (slightly offset outward)
            const pTip = arrowOrigin.clone().add(momentumDir.clone().multiplyScalar(momentumLength + 0.18));
            group.add(createLabel('p', pTip, COLOR_WARM_ORANGE, null, true));

            // Do not add other 3D labels for momentum/angles here
            return group;
        }

        // =================== 初始化场景 ===================
        let detectorCylinder, pointP, track, phiArc, psiArc, lambdaArc, zPlane, labels, axes, momentumIndicator;
        let zPlaneLabelsGroup; // group for labels projected onto Z plane
        let zPlaneProjGroup; // group for projected geometry (circles, arrows, arcs)

        function initScene() {
            // 清除旧元素
            if (detectorCylinder) scene.remove(detectorCylinder);
            if (pointP) scene.remove(pointP);
            if (track) scene.remove(track);
            if (phiArc) scene.remove(phiArc);
            if (psiArc) scene.remove(psiArc);
            if (lambdaArc) scene.remove(lambdaArc);
            if (zPlane) scene.remove(zPlane);
            if (labels) scene.remove(labels);
            if (axes) scene.remove(axes);
            if (momentumIndicator) scene.remove(momentumIndicator);

            // 创建新元素
            detectorCylinder = createDetectorCylinder();
            pointP = createPointP();
            track = createTrack();
            phiArc = createPhiArc();
            psiArc = createPsiArc();
            lambdaArc = createLambdaArc();
            zPlane = createZPlane();
            labels = createTextLabels();
            axes = createCoordinateAxes();
            momentumIndicator = createMomentumIndicator();

            // create or reset Z-plane labels and projection groups
            if (zPlaneLabelsGroup) scene.remove(zPlaneLabelsGroup);
            zPlaneLabelsGroup = new THREE.Group();
            scene.add(zPlaneLabelsGroup);
            if (zPlaneProjGroup) scene.remove(zPlaneProjGroup);
            zPlaneProjGroup = new THREE.Group();
            scene.add(zPlaneProjGroup);

            // 计算点P的位置并设置
            const phiRad = THREE.MathUtils.degToRad(params.phi0);
            const x0 = params.cylinder_radius * Math.cos(phiRad);
            const y0 = params.cylinder_radius * Math.sin(phiRad);
            pointP.position.set(x0, y0, params.z0);

            // 添加到场景
            scene.add(detectorCylinder);
            scene.add(pointP);
            scene.add(track);
            scene.add(phiArc);
            scene.add(psiArc);
            scene.add(lambdaArc);
            scene.add(zPlane);
            scene.add(labels);
            scene.add(axes);
            scene.add(momentumIndicator);

            // build projections of selected elements onto Z plane labels
            try {
                buildZPlaneProjections();
            } catch (e) {
                console.warn('buildZPlaneProjections failed', e);
            }
        }

        // =================== UI控制 ===================

        // 初始化UI值显示
        document.getElementById('kappa-value').textContent = params.kappa.toFixed(1);
        document.getElementById('psi-value').textContent = params.psi + '°';
        document.getElementById('phi-value').textContent = params.phi0 + '°';
        document.getElementById('lambda-value').textContent = params.lambda.toFixed(1);
        document.getElementById('z0-value').textContent = params.z0.toFixed(1);

        // 滑块控制
        document.getElementById('kappa-slider').addEventListener('input', (e) => {
            params.kappa = parseFloat(e.target.value);
            document.getElementById('kappa-value').textContent = params.kappa.toFixed(1);
            initScene();
        });

        document.getElementById('psi-slider').addEventListener('input', (e) => {
            params.psi = parseInt(e.target.value);
            document.getElementById('psi-value').textContent = params.psi + '°';
            initScene();
        });

        document.getElementById('phi-slider').addEventListener('input', (e) => {
            params.phi0 = parseInt(e.target.value);
            document.getElementById('phi-value').textContent = params.phi0 + '°';
            initScene();
        });

        document.getElementById('lambda-slider').addEventListener('input', (e) => {
            params.lambda = parseFloat(e.target.value);
            document.getElementById('lambda-value').textContent = params.lambda.toFixed(1);
            initScene();
        });
        document.getElementById('z0-slider').addEventListener('input', (e) => {
            params.z0 = parseFloat(e.target.value);
            z0 = params.z0;
            document.getElementById('z0-value').textContent = params.z0.toFixed(1);
            initScene();
        });

        // 按钮控制
        document.getElementById('reset-view').addEventListener('click', () => {
            controls.reset();
            updateStatus('View reset');
        });

        document.getElementById('reset-all').addEventListener('click', () => {
            params.kappa = 0.4;
            params.psi = 30;
            params.phi0 = 45;
            params.lambda = 0.5;
            params.z0 = 0;

            document.getElementById('kappa-slider').value = params.kappa;
            document.getElementById('psi-slider').value = params.psi;
            document.getElementById('phi-slider').value = params.phi0;
            document.getElementById('lambda-slider').value = params.lambda;

            document.getElementById('kappa-value').textContent = params.kappa.toFixed(1);
            document.getElementById('psi-value').textContent = params.psi + '°';
            document.getElementById('phi-value').textContent = params.phi0 + '°';
            document.getElementById('lambda-value').textContent = params.lambda.toFixed(1);
            document.getElementById('z0-value').textContent = params.z0.toFixed(1);

            initScene();
            updateStatus('All parameters reset');
        });

        // =================== 辅助函数 ===================
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        // =================== 初始化并运行动画 ===================
        initScene();

        // -------- 投影小窗专用 Three 对象（使用主 renderer 的 viewport 渲染，避免创建第二个 WebGLContext） --------
        const xyScene = new THREE.Scene();
        const xyCam = new THREE.OrthographicCamera(
            -6, 6,   // left, right
            6, -6,  // top, bottom
            -1, 20);
        // 将 XY 相机移出到 +Z 方向，确保能看到 z=0 平面上的对象
        xyCam.position.set(0, 0, 10);
        xyCam.lookAt(0, 0, 0);
        // 纯色背景（白色）
        xyScene.background = new THREE.Color(COLOR_WHITE);
        // 使用主 renderer 对小视图进行绘制
        renderer.autoClear = false;

        function buildXYProjections() {
            // 清旧对象
            [xyTrack, xyPArr, xyPhiArc, xyPsiArc].forEach(o => o && xyScene.remove(o));

            /* 1. 径迹投影（只取 x,y） */
            const pts2D = [];
            const num = 200;
            for (let i = 0; i <= num; i++) {
                const t = (i / num) * 4 * Math.PI;
                const k = Math.sign(params.kappa);
                const theta = k * t;
                const R = 1 / (2 * Math.abs(params.kappa));
                const psiRad = THREE.MathUtils.degToRad(params.psi);
                const phiRad = THREE.MathUtils.degToRad(params.phi0);
                const x0 = params.cylinder_radius * Math.cos(phiRad);
                const y0 = params.cylinder_radius * Math.sin(phiRad);
                const pT = 1; // 归一化
                const x = x0 + (Math.sin(theta + psiRad) - Math.sin(psiRad)) * R / pT;
                const y = y0 + (Math.cos(psiRad) - Math.cos(theta + psiRad)) * R / pT;
                pts2D.push(new THREE.Vector3(x, y, 0)); // z=0 放在 XY 平面
            }
            xyTrack = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints(pts2D),
                new THREE.LineBasicMaterial({ color: COLOR_SOFT_RED, linewidth: 2 }));
            xyScene.add(xyTrack);

            /* 2. 动量箭头投影 */
            const phiRad = THREE.MathUtils.degToRad(params.phi0);
            const psiRad = THREE.MathUtils.degToRad(params.psi);
            const x0 = params.cylinder_radius * Math.cos(phiRad);
            const y0 = params.cylinder_radius * Math.sin(phiRad);
            const dir2D = new THREE.Vector3(Math.cos(psiRad), Math.sin(psiRad), 0);
            xyPArr = new THREE.ArrowHelper(
                dir2D, new THREE.Vector3(x0, y0, 0),
                2.5, COLOR_WARM_ORANGE, 0.4, 0.2);
            xyScene.add(xyPArr);

            /* 3. φ 弧投影 */
            const phiPts = [];
            for (let i = 0; i <= 30; i++) {
                const a = (i / 30) * phiRad;
                phiPts.push(new THREE.Vector3(
                    (params.cylinder_radius + 0.1) * Math.cos(a),
                    (params.cylinder_radius + 0.1) * Math.sin(a), 0));
            }
            xyPhiArc = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints(phiPts),
                new THREE.LineBasicMaterial({ color: COLOR_PINE_GREEN }));
            xyScene.add(xyPhiArc);

            /* 4. ψ 弧投影 */
            const psiPts = [];
            const arcR = 1.5;
            for (let i = 0; i <= 20; i++) {
                const a = (i / 20) * psiRad;
                psiPts.push(new THREE.Vector3(
                    x0 + arcR * Math.cos(a),
                    y0 + arcR * Math.sin(a), 0));
            }
            xyPsiArc = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints(psiPts),
                new THREE.LineBasicMaterial({ color: COLOR_SAND_BROWN }));
            xyScene.add(xyPsiArc);
        }

        // 在 Z 平面上创建投影标签（px, py, pt, φ, ψ, track, cylinder, X, Y）
        function buildZPlaneProjections() {
            if (!zPlane) return;

            // clear old groups
            if (zPlaneLabelsGroup) while (zPlaneLabelsGroup.children.length) zPlaneLabelsGroup.remove(zPlaneLabelsGroup.children[0]);
            if (zPlaneProjGroup) while (zPlaneProjGroup.children.length) zPlaneProjGroup.remove(zPlaneProjGroup.children[0]);

            // positions
            const zPos = zPlane.position.z + 0.02; // geometry sits slightly above plane
            const labelZ = zPlane.position.z + 0.08; // labels a bit higher to avoid overlap

            // common params
            const phiRad = THREE.MathUtils.degToRad(params.phi0);
            const psiRad = THREE.MathUtils.degToRad(params.psi);
            const x0 = params.cylinder_radius * Math.cos(phiRad);
            const y0 = params.cylinder_radius * Math.sin(phiRad);
            const zP = params.z0;

            // --- cylinder projection: circle centered at origin ---
            (function(){
                const seg = 128;
                const pts = [];
                for (let i=0;i<=seg;i++){
                    const a = (i/seg) * Math.PI * 2;
                    pts.push(new THREE.Vector3(params.cylinder_radius * Math.cos(a), params.cylinder_radius * Math.sin(a), zPos));
                }
                const circ = new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), new THREE.LineBasicMaterial({color: COLOR_LAKE_CYAN, linewidth: 1}));
                zPlaneProjGroup.add(circ);
            })();

            // --- track projection: use same pts as XY projection but at zPos ---
            (function(){
                const pts2D = [];
                const num = 200;
                for (let i = 0; i <= num; i++) {
                    const t = (i / num) * 4 * Math.PI;
                    const k = Math.sign(params.kappa);
                    const theta = k * t;
                    const R = 1 / (2 * Math.abs(params.kappa));
                    const pT = 1; // 归一化
                    const x = x0 + (Math.sin(theta + psiRad) - Math.sin(psiRad)) * R / pT;
                    const y = y0 + (Math.cos(psiRad) - Math.cos(theta + psiRad)) * R / pT;
                    pts2D.push(new THREE.Vector3(x, y, zPos));
                }
                const trackLine = new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts2D), new THREE.LineBasicMaterial({color: COLOR_SOFT_RED, linewidth: 2}));
                zPlaneProjGroup.add(trackLine);
            })();

            // --- momentum components projections as arrows (px, py, pt) ---
            (function(){
                const ptVal = params.kappa !== 0 ? 1 / Math.abs(params.kappa) : 10;
                const pxVal = ptVal * Math.cos(psiRad);
                const pyVal = ptVal * Math.sin(psiRad);
                // base point is projection of P onto plane
                const base = new THREE.Vector3(x0, y0, zPos);

                // px arrow (along X axis)
                const dirPx = new THREE.Vector3(Math.sign(pxVal),0,0).normalize();
                const pxArrow = new THREE.ArrowHelper(dirPx, base, Math.abs(pxVal), COLOR_SOFT_RED, 0.2, 0.1);
                zPlaneProjGroup.add(pxArrow);
                zPlaneLabelsGroup.add(createLabel('px', new THREE.Vector3(base.x + dirPx.x * (Math.abs(pxVal)+0.2), base.y, labelZ), COLOR_SOFT_RED, null, true));

                // py arrow (along Y axis)
                const dirPy = new THREE.Vector3(0, Math.sign(pyVal),0).normalize();
                const pyArrow = new THREE.ArrowHelper(dirPy, base, Math.abs(pyVal), COLOR_PINE_GREEN, 0.2, 0.1);
                zPlaneProjGroup.add(pyArrow);
                zPlaneLabelsGroup.add(createLabel('py', new THREE.Vector3(base.x, base.y + dirPy.y * (Math.abs(pyVal)+0.2), labelZ), COLOR_PINE_GREEN, null, true));

                // pt arrow (transverse) - direction in XY plane
                const dirPt = new THREE.Vector3(Math.cos(psiRad), Math.sin(psiRad), 0).normalize();
                const ptArrow = new THREE.ArrowHelper(dirPt, base, ptVal, COLOR_LAKE_CYAN, 0.25, 0.12);
                zPlaneProjGroup.add(ptArrow);
                zPlaneLabelsGroup.add(createLabel('pt', new THREE.Vector3(base.x + dirPt.x * (ptVal+0.2), base.y + dirPt.y * (ptVal+0.2), labelZ), COLOR_LAKE_CYAN, null, true));
            })();

            // --- φ and ψ as arcs between vectors (draw centered at origin for φ, at P for angle between radial and momentum for ψ) ---
            (function(){
                // φ: arc from 0 to phiRad centered at origin
                const seg = 40;
                const rphi = params.cylinder_radius * 0.5;
                const phiPts = [];
                // center φ arc at midpoint of O and P (move halfway towards O)
                const centerX = 0;
                const centerY = 0;
                for (let i = 0; i <= seg; i++) {
                    const a = (i / seg) * phiRad;
                    phiPts.push(new THREE.Vector3(centerX + rphi * Math.cos(a), centerY + rphi * Math.sin(a), zPos));
                }
                const phiLine = new THREE.Line(new THREE.BufferGeometry().setFromPoints(phiPts), new THREE.LineBasicMaterial({ color: COLOR_PINE_GREEN }));
                zPlaneProjGroup.add(phiLine);
                const phiMidAngle = phiRad / 2;
                const phiLabelPos = new THREE.Vector3(
                    centerX + rphi * Math.cos(phiMidAngle),
                    centerY + rphi * Math.sin(phiMidAngle),
                    labelZ
                );
                // 计算径向单位向量（2D）
                const phiDir2 = new THREE.Vector2(phiLabelPos.x - centerX, phiLabelPos.y - centerY).normalize();
                phiLabelPos.x += phiDir2.x * 0.25; // 沿径向再外推 0.25 单位（可调整）
                phiLabelPos.y += phiDir2.y * 0.25;
                zPlaneLabelsGroup.add(createLabel('φ', phiLabelPos, COLOR_PINE_GREEN, null, true));
                // ψ: angle between radial vector (from origin to P) and momentum direction; draw arc centered at P
                // For ψ: draw arc between px direction and pt (transverse momentum) direction
                const ptVal_local = params.kappa !== 0 ? 1 / Math.abs(params.kappa) : 10;
                const pxVal_local = ptVal_local * Math.cos(psiRad);
                const dirPt = new THREE.Vector2(Math.cos(psiRad), Math.sin(psiRad));
                // start angle: px direction (along +X if px>=0, otherwise -X)
                const startA = (pxVal_local >= 0) ? 0 : Math.PI;
                // end angle: pt direction
                const endA = Math.atan2(dirPt.y, dirPt.x);
                // normalize so arc goes shortest way
                let a0 = startA;
                let a1 = endA;
                while (a1 - a0 > Math.PI) a1 -= Math.PI*2;
                while (a1 - a0 < -Math.PI) a1 += Math.PI*2;
                const arcuSeg = 30;
                const rpsi = 1.2;
                const psiPts = [];
                for (let i=0;i<=arcuSeg;i++){
                    const a = a0 + (i/arcuSeg) * (a1 - a0);
                    psiPts.push(new THREE.Vector3(x0 + rpsi * Math.cos(a), y0 + rpsi * Math.sin(a), zPos));
                }
                const psiLine = new THREE.Line(new THREE.BufferGeometry().setFromPoints(psiPts), new THREE.LineBasicMaterial({color: COLOR_SOFT_RED}));
                zPlaneProjGroup.add(psiLine);
                // label at mid angle on psi arc
                const midA = a0 + 0.5*(a1-a0);
                const psiLabelPos = new THREE.Vector3(
                    x0 + rpsi * Math.cos(midA),
                    y0 + rpsi * Math.sin(midA),
                    labelZ + 0.02
                );
                // 径向偏移（中心是 P，即 x0,y0）
                const psiDir2 = new THREE.Vector2(psiLabelPos.x - x0, psiLabelPos.y - y0).normalize();
                psiLabelPos.x += psiDir2.x * 0.25; // 推开距离可以相同或略有差别
                psiLabelPos.y += psiDir2.y * 0.25;
                zPlaneLabelsGroup.add(createLabel('ψ', psiLabelPos, COLOR_SOFT_RED, null, true));
            })();

            // --- X axis projection on Z plane (visual aid only, no label) ---
            (function() {
                const axisLen = 8;
                const xPts = [
                    new THREE.Vector3(-axisLen, 0, zPos),
                    new THREE.Vector3(axisLen, 0, zPos)
                ];
                const xLine = new THREE.Line(new THREE.BufferGeometry().setFromPoints(xPts), new THREE.LineBasicMaterial({ color: COLOR_GRAY, linewidth: 1 }));
                zPlaneProjGroup.add(xLine);
            })();

            // note: do not add labels for cylinder/track as requested

            // also add projection of O->P dashed line onto Z plane
            (function(){
                const zPos = zPlane ? zPlane.position.z + 0.02 : -params.cylinder_length/2 + 0.02;
                const opProj = createDashedLine([
                    new THREE.Vector3(0, 0, zPos),
                    new THREE.Vector3(x0, y0, zPos)
                ], { color: COLOR_GRAY, dashSize: 0.5, gapSize: 0.5 });
                if (zPlaneProjGroup) zPlaneProjGroup.add(opProj);
            })();
        }

        // -------- 构建 2D 线条/箭头的空壳 --------
        let xyTrack, xyPArr, xyPhiArc, xyPsiArc;   // 会随参数更新


        // 动画循环
        function animate() {
            buildXYProjections();   // 参数变化即重绘
            requestAnimationFrame(animate);
            controls.update();

            // 首先清空主画布并绘制主场景
            renderer.clear();
            renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
            renderer.setScissorTest(false);
            renderer.render(scene, camera);

            // 然后在右下角绘制小视图（使用主 renderer 的 viewport + scissor）
            const xySize = 200; // 固定小窗像素大小
            const margin = 20;
            const px = window.innerWidth - xySize - margin;
            const py = margin;

            renderer.clearDepth(); // 保证小视图不被深度缓存影响
            renderer.setScissor(px, py, xySize, xySize);
            renderer.setViewport(px, py, xySize, xySize);
            renderer.setScissorTest(true);
            renderer.render(xyScene, xyCam);

            // 关闭 scissor 测试
            renderer.setScissorTest(false);
        }
        animate();

        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 初始状态
        updateStatus('test');
    </script>

</body>

</html>
